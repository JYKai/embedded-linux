# Toolchain

툴체인은 임베디드 리눅스의 첫 번째 요소이자 프로젝트의 시작점이다.

- 디바이스에서 실행될 모든 코드를 툴체인을 이용해 컴파일하며, 이 초기 단계에서의 선택이 최종 산출물에 엄청난 영향을 미칠 것이다.
- 해당 프로세스를 위한 최적의 명령어 세트를 사용함으로써 하드웨어를 효과적으로 사용할 수 있어야 한다.
- 프로젝트 내내 바뀌지 않아야 한다.

☑️ **To-do**
crosstool-NG 를 사용하여 툴체인을 소스 코드로부터 빌드


## ▶️ 기술적 요구 사항
```
$ sudo apt-get install autoconf automake bison bzip2 cmake \
flex g++ gawk gcc \
gettext git gperf help2man libncurses5-dev libstdc++6 libtool \
libtool-bin make \
patch python3-dev rsync texinfo unzip wget xz-utils
```

## ▶️ 툴체인 소개
소스 코드를 타깃 장치에서 실행할 수 있는 실행 파일로, 컴파일러, 링커, 런타임 라이브러리를 포함하는 컴파일 도구들의 집합이다.
- 부트로더, 커널, 루트 파일시스템과 같은 리눅스 시스템의 나머지 세 요소를 빌드하기 위해 툴체인이 필요하다.
- 흔히 리눅스용 툴체인은 GNU 프로젝트에서 만들어진 요소에 기반을 두고 있다.
    - 지난 몇 년 동안, Clang 컴파일러와 관련된 LLVM 프로젝트가 GNU 툴체인의 쓸 만한 대안이 될 정도로 발전했다.
    - 라이선스 = LLVM : BSD, GNU : GPL
- GNU 툴체인의 구성 요소
    - Binutils
        - 어셈블러와 링커를 포하하는 바이너리 유틸리티의 집합
    - GCC(GNU Compiler Collection)
        - C와 여러 언어를 위한 컴파일러
        - 공통 백엔드를 사용해 어셈블러 코드를 만들고, GNU 어셈블러로 넘긴다.
    - C 라이브러리
        - POSIX 규격에 기반을 둔 표준 API
        - 애플리케이션에서 운영체제 커널로 연결되는 주요 인터페이스

## ▶️ 툴체인의 종류
1. 네이티브
    - 툴체인이 만들어내는 프로그램과 같은 종류의 시스템, 때로는 실제로 같은 시스템에서 실행된다.
2. 크로스
    - 툴체인이 타깃 기계와 다른 종류의 시스템에서 실행된다.
    - 빠른 데스크톱PC에서 개발한 다음 임베디드 디바이스에 로드해 테스트할 수 있다.

대부분의 임베디드 리눅스 개발이 크로스 개발 툴체인을 사용해 이루어진다.

**호스트와 타깃이 같은 아키텍처를 사용한다면?**  
- 호스트와 타깃이 같은 아키텍처를 사용한다고 해서 호스트에서 네이티브로 컴파일하고 단순히 타깃으로 바이너리를 복사하면 어느 선까지는 동작하지만, 호스트 배포판이 타깃보다 좀 더 자주 갱신되거나 타깃용 코드를 빌드하는 엔지니어가 호스트 개발 라이브러리와 약간 다른 버전을 같게 될 가능성이 높다. -> 프로젝트 기간 내내 툴체인이 변치 않아야 한다는 원칙을 위반하게 될 것이다.


## ▶️ CPU 아키텍처
툴체인은 타깃 CPU의 특징에 맞게 빌드되어야 한다.

**툴체인을 빌드할 때 쓰인 조합 확인**  
```bash
$ gcc -dumpmachine
aarch64(CPU)-linux(커널)-gnu(사용자 공간)
```

## ▶️ C 라이브러리 고르기
- glibc
    - 표준 GNU C 라이브러리
    - 크기가 크고 최근까지 구성 변경이 용이하지 않지만, POSIX API의 가장 완전한 구현이다.

...

## ▶️ 크로스 컴파일 기술

<details>
<summary>크로스 컴파일이란?</summary>
<div markdown='1'>

---

크로스 컴파일은 개발자가 사용 중인 컴퓨터(호스트 컴퓨터)에서 실행되지 않고, 다른 시스템(타겟 시스템)에서 실행될 프로그램을 컴파일하는 방법입니다. 쉽게 말해, 우리가 프로그램을 만들 때는 보통 그 프로그램을 바로 우리가 사용 중인 컴퓨터에서 실행하기 위해 만드는데, 크로스 컴파일은 우리가 사용 중인 컴퓨터가 아닌 다른 컴퓨터나 기기에서 실행될 프로그램을 만드는 것입니다.

---
</div>
</details>

</br>

**흔히 사용되는 빌드 시스템**  
- 툴체인이 주로 make 변수 CROSS_COMPILE로 제어되는 순사한 makefile들
- Autotools로 알려진 GNU 빌드 시스템
- CMake

### 단순 makefile
리눅스 커널, U-Boot 부트로더, Busybox를 포함한 몇몇 중요한 패키지는 크로스 컴파일이 매우 쉽다.
- 각각을 컴파일할 때 make 변수 CROSS_COMPILE에 툴체인 접두어를 붙이기만 하면 된다.

**Ex. Busybox**  
```$ make CROSS_COMPILE=arm-cortex_a8-linux-gnueabihf-```

<details>
<summary>Busybox란?</summary>
<div markdown='1'>

---

Busybox는 임베디드 리눅스 시스템을 위한 소프트웨어로, 여러 가지 유틸리티 프로그램(명령어)을 하나의 실행 파일로 통합한 것입니다. 일반적인 리눅스 시스템에서 사용하는 다양한 명령어들을 Busybox 하나로 대체할 수 있습니다. 이것은 공간이 제한된 임베디드 시스템에서 매우 유용합니다.

---
</div>
</details>

</br>

### Autotools
Autotools라는 이름은 여러 오픈소스 프로젝트에서 빌드 시스템으로 쓰이는 한 무리의 도구들을 가리킨다.
- GNU Autoconf
- GNU Automake
- GNU Libtool
- Gnulib  

Autotools의 역할은 서로 다른 버전의 컴파일러와 라이브러리, 서로 다른 헤더 파일 위치, 다른 패키지와의 의존 관계를 처리해서 패키지를 컴파일하는 서로 다른 여러 가지 시스템 사이의 차이를 완화하는 것이다.
- Autotools를 사용하는 패키지는 의존 관계를 확인하고 makefile을 만들어내는 configure라는 이름의 스크립트를 담고 있다.
    - configure 스크립트는 특정 기능을 켜고 끄는 선택도 제공한다.
    - ```./configure -help```